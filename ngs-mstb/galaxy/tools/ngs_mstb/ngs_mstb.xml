<macros>
<!-- Generic Cheetah functions - import as Galaxy XML macro and dereference as a macro token -->
<token name="@CHEETAH_LIB@">
<!-- **Note** Cheetah statements below should be indented to the start of
the line, and then imported at the start of the line,
in order to avoid creating extra indentation in Cheetah outputs -->
## Construct CLI argument from Tool XML variable
## Example: $bind_arg("section_radar_sfx.radar_sfx_version") =>
## --radar-sfx-version $section_radar_sfx.radar_sfx_version
## but if $section_radar_sfx.radar_sfx_version is None (e.g. nothing was entered for
## an optional field), then nothing at all will be generated.
## If the prefix variable is provided, it will be used as-is without trying to guess
## the prefix from the variable name or applying the to_dash transformation.

#def bind_arg($var,$prefix=None,$sep=" ",$pref_open="",$pref_close="",$val_open="'",$val_close="'",$to_dash=True,$prefix_start="--")
#set $val = $getVar($var)
#if $prefix is None:
#set $prefix = $var.split(".")[-1]
#if $to_dash
#set $prefix = $prefix.replace("_","-")
#end if
#set $prefix = $prefix_start+$prefix
#end if
#if $val
$pref_open$prefix$pref_close$sep$val_open$val$val_close#slurp
#end if
#end def

## keep underscore in the argument name: my_option => --my_option
#def bind_arg_under($var,$prefix=None,$sep=" ",$pref_open="",$pref_close="",$val_open="",$val_close="",$prefix_start="--")
$bind_arg($var,$prefix,$sep=$sep,$pref_open=$pref_open,$pref_close=$pref_close,$val_open=$val_open,$val_close=$val_close,$to_dash=False,$prefix_start=$prefix_start)#slurp
#end def

## Makes a call to bind_arg that generates key: value pair for YAML to use
## in the configfile generation

#def bind_arg_yaml($var,$prefix=None,$sep=": ",$val_open="",$val_close="")
$bind_arg($var,$prefix,$sep=$sep,$pref_open="",$pref_close="",$val_open=$val_open,$val_close=$val_close,$to_dash=False,$prefix_start="")#slurp
#end def
<!-- YAML either needs spaces after the colon, or the keys delimited by double quotes JSON-style. It will treat this a:1 as a single scalar.
We surround keys by double quotes in order to avoid the alternative of putting spaces into the string.
 Commas do not need to be followed by spaces in YAML notation -->
#def bind_arg_yaml_dense($var,$prefix=None,$sep=":",$val_open="",$val_close=",")
$bind_arg($var,$prefix,$sep=$sep,$pref_open='"',$pref_close='"',$val_open=$val_open,$val_close=$val_close,$to_dash=False,$prefix_start="")#slurp
#end def

#def get_api_job_id($dataset): $__app__.security.encode_id($dataset.creating_job.id)

#def get_api_dataset_id($dataset): $__app__.security.encode_id($dataset.id)


#def compute_sig_file($file,$sig=None,$extra_data=None)
#if not $sig
#set $sig = $file+'.sig'
#end if
python -m MICGENT.sig --config '$__tool_directory__/secrets.yaml' file-sig #if $extra_data then "'--extra-data' '" + $extra_data + "'" else '' # '--out-file' '$sig' '$file'
#end def

#def check_sig_file($file,$msg,$sig=None,$extra_data=None)
#if not $sig
#set $sig = $file+'.sig'
#end if
python -m MICGENT.sig --config '$__tool_directory__/secrets.yaml' file-sig-cmp-msg #if $extra_data then "'--extra-data' '" + $extra_data + "'" else '' # '--msg' '$msg' '$sig' '$file'
#end def

<!-- Compute signature and check against a pre-computed signature of a dataset. Signature is saved in a pre-defined file
name under dataset's extra files directory. Chain with && shell pipe after/before tool command line in order to
ensure that the input dataset has not been modified outside of this particular server.
The dataset ID is mixed with data to ensure two signatures cannot be swapped between two identical datasets. For that, the
internal dataset ID is first converted into API dataset ID to make it easier checking signature from the command line if needed.
The API conversion itself depends on the strength of Galaxy internal hashing. However, considering that the dataset API IDs for this
mixing process can be only generated by creating actual Galaxy datasets (with internal IDs being incremented), the risk of finding
a collision appears to be miniscule.
-->
#def compute_sig($dataset)
$compute_sig_file($dataset,$sig=$dataset.extra_files_path+'/dataset.sig',$extra_data=$get_api_dataset_id($dataset))
#end def

#def check_sig($dataset)
$check_sig_file($dataset,$msg='Signature mismatch for input dataset '+str($dataset.hid)+' Dataset has not been produced by this server.',
$sig=$dataset.extra_files_path+'/dataset.sig',$extra_data=$get_api_dataset_id($dataset))
#end def

#def prov_cmd_base()
	python -m MICGENT.galaxy.api --config $__tool_directory__/secrets.yaml job-info-export
#end def

<!-- Export job provenance data as the output dataset.
Call it inside the job before other commands and pass to it the output dataset parameter. 
That will: 
- create ./provenance/tag/job_user.yaml file with a recursive job provenance, as well as other job
  provenance files in the same directory. The latter job command components can access these files there
- copy job_user.yaml file into the target output dataset location
-->
#def galaxy_provenance_out($dataset,$out_dir)
#set $job_id = $get_api_job_id($dataset)
$prov_cmd_base() '--job-id' '$job_id' '--out-job-yaml' '$out_dir/job.yaml' '--out-job-user-yaml' '$out_dir/job_user.yaml' '--recursive' '--make-sig'
&amp;&amp;
cp '$out_dir/job_user.yaml' '$dataset'
#end def

</token>
</macros>
